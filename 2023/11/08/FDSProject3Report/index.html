

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Ice Bear">
  <meta name="keywords" content="">
  
    <meta name="description" content="FDS Project3 Report Chapter 1 Introduction Railway transportation remains one of the most utilized methods for long-distance travel, offering a balance between speed, cost, and convenience. Efficient">
<meta property="og:type" content="article">
<meta property="og:title" content="FDSProject3Report">
<meta property="og:url" content="http://example.com/2023/11/08/FDSProject3Report/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="FDS Project3 Report Chapter 1 Introduction Railway transportation remains one of the most utilized methods for long-distance travel, offering a balance between speed, cost, and convenience. Efficient">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-11-08T03:04:23.000Z">
<meta property="article:modified_time" content="2023-11-10T12:54:40.790Z">
<meta property="article:author" content="Ice Bear">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>FDSProject3Report - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.5","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="FDSProject3Report"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-11-08 11:04" pubdate>
          2023年11月8日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          26k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          216 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">FDSProject3Report</h1>
            
            
              <div class="markdown-body">
                
                <h3 id="FDS-Project3-Report">FDS Project3 Report</h3>
<h3 id="Chapter-1-Introduction">Chapter 1 Introduction</h3>
<p>Railway transportation remains one of the most utilized methods for long-distance travel, offering a balance between speed, cost, and convenience. Efficient pathfinding algorithms are critical in optimizing railway networks, ensuring minimal travel time and enhancing passenger experience. The conventional approach to pathfinding in railway networks typically involves finding the shortest route from the origin to the destination. However, this approach does not account for various real-world scenarios such as network congestion, scheduled maintenance, or the traveler’s preference for a non-shortest path due to reasons like sightseeing.</p>
<p>In light of these considerations, there emerges a need for an algorithm capable of identifying not just the shortest path but also alternative routes that are the next best in terms of travel distance. Such an algorithm expands the operational flexibility of railway networks and accommodates a broader range of traveler preferences.</p>
<h3 id="Chapter2-Algorithm-Specification">Chapter2 Algorithm Specification</h3>
<h4 id="Overview">Overview</h4>
<p>The core problem addressed in this report is the computation of the second-shortest path in a directed railway network graph. The approach taken can be segmented into two primary components: the Dijkstra algorithm’s application to identify the shortest path and the identification of cycles to facilitate the discovery of the second-shortest path when the direct approach is insufficient.</p>
<h4 id="Shortest-Path-Computation">Shortest Path Computation</h4>
<p>The algorithm begins with a conventional Dijkstra’s algorithm to calculate the shortest path from the start station to the destination. Each node’s minimum distance from the start node is stored, along with its predecessor, to reconstruct the path upon completion of the algorithm.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Dijkstra</span><span class="hljs-params">(Graph* <span class="hljs-built_in">map</span>)</span> &#123;<br>    <span class="hljs-comment">// Start with node 1 in the min heap (priority queue)</span><br>    MinHeap[Head] = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> HeapSize = <span class="hljs-number">1</span>; <span class="hljs-comment">// Initialize heap size</span><br><br>    <span class="hljs-comment">// Loop to process all nodes in the graph</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>        <span class="hljs-comment">// Extract node with the smallest distance</span><br>        <span class="hljs-type">int</span> currentNode = MinHeap[Head];<br><br>        <span class="hljs-comment">// Access all edges connected to the current node</span><br>        Edge* currentEdge = <span class="hljs-built_in">map</span>-&gt;vertice[currentNode]-&gt;next;<br><br>        <span class="hljs-comment">// Mark the current node as visited</span><br>        isvisited[currentNode] = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">// Remove the top element from the heap</span><br>        <span class="hljs-keyword">if</span>(HeapSize == <span class="hljs-number">1</span>) &#123;<br>            HeapSize--;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            MinHeap[Head] = MinHeap[HeapSize--];<br>            percolateDown(Head, HeapSize); <span class="hljs-comment">// Restore heap property</span><br>        &#125;<br><br>        <span class="hljs-comment">// Traverse all edges of the current node</span><br>        <span class="hljs-keyword">while</span> (currentEdge != <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-type">int</span> nextNode = currentEdge-&gt;to; <span class="hljs-comment">// Get the adjacent node</span><br><br>            <span class="hljs-comment">// Check if a shorter path is found</span><br>            <span class="hljs-keyword">if</span> (currentEdge-&gt;weight + <span class="hljs-built_in">map</span>-&gt;vertice[currentNode]-&gt;minnRoute &lt; <span class="hljs-built_in">map</span>-&gt;vertice[nextNode]-&gt;minnRoute) &#123;<br>                <span class="hljs-comment">// Update the distance and predecessor</span><br>                <span class="hljs-built_in">map</span>-&gt;vertice[nextNode]-&gt;minnRoute = currentEdge-&gt;weight + <span class="hljs-built_in">map</span>-&gt;vertice[currentNode]-&gt;minnRoute;<br>                <span class="hljs-built_in">map</span>-&gt;vertice[nextNode]-&gt;predecessor = currentNode;<br><br>                <span class="hljs-comment">// Add the node to the heap if it hasn&#x27;t been visited</span><br>                <span class="hljs-keyword">if</span> (!isvisited[nextNode]) &#123;<br>                    MinHeap[++HeapSize] = nextNode;<br>                    percolateUp(HeapSize); <span class="hljs-comment">// Maintain heap property</span><br>                    isvisited[nextNode] = <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-comment">// Move to the next edge in the adjacency list</span><br>            currentEdge = currentEdge-&gt;next;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="Edge-Blocking-and-Re-evaluation">Edge Blocking and Re-evaluation</h4>
<p>Subsequently, the algorithm iteratively “blocks” sections of this shortest path by temporarily assigning an excessively high weight to the edges in the path and then re-applying the Dijkstra algorithm. This process is intended to reveal alternate routes that are longer than the shortest path but potentially the second-shortest. These paths are evaluated against the existing second-shortest path candidate, with the shortest among them being selected.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Block each path in the shortest path and run Dijkstra&#x27;s algorithm again to find the next shortest path</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= inde - <span class="hljs-number">1</span>; i++) &#123; <span class="hljs-comment">// For a path with n nodes, there are n-1 edges</span><br>        <span class="hljs-comment">// Reset the visited status for all nodes</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) isvisited[j] = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// Get the edge in the stored shortest path. If track[] stored 6 3 2 1, and i=1, then currentEdge is the first edge from node 3</span><br>        Edge* currentEdge = graph-&gt;vertice[track[i+<span class="hljs-number">1</span>]]-&gt;next;<br>        <span class="hljs-comment">// Find the edge pointing to track[i]</span><br>        <span class="hljs-keyword">while</span>(currentEdge-&gt;to != track[i]) currentEdge = currentEdge-&gt;next;<br><br>        <span class="hljs-comment">// Store the original length of the edge</span><br>        <span class="hljs-type">int</span> temp = currentEdge-&gt;weight;<br>        <span class="hljs-comment">// Assign a very high value to the current edge, effectively blocking it from being used</span><br>        currentEdge-&gt;weight = Max_int - <span class="hljs-number">5000000</span>;<br><br>        <span class="hljs-comment">// Initialize the graph to run Dijkstra&#x27;s algorithm</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= m; k++) &#123;<br>            graph-&gt;vertice[k]-&gt;minnRoute = Max_int;<br>            graph-&gt;vertice[k]-&gt;predecessor = <span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-comment">// Set the starting node&#x27;s distance to 0 and predecessor to itself</span><br>        graph-&gt;vertice[<span class="hljs-number">1</span>]-&gt;minnRoute = <span class="hljs-number">0</span>;<br>        graph-&gt;vertice[<span class="hljs-number">1</span>]-&gt;predecessor = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">// Run Dijkstra&#x27;s algorithm with the current edge blocked</span><br>        Dijkstra(graph);<br><br>        <span class="hljs-comment">// Print the updated distances and predecessors after running Dijkstra</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>, graph-&gt;vertice[j]-&gt;minnRoute, graph-&gt;vertice[j]-&gt;predecessor);<br><br>        <span class="hljs-comment">// Restore the original length of the current edge</span><br>        currentEdge-&gt;weight = temp;<br><br>        <span class="hljs-comment">// Update the length of the second shortest path</span><br>        <span class="hljs-comment">// Check if the new path is shorter than the second shortest but longer than the shortest path</span><br>        <span class="hljs-keyword">if</span>(graph-&gt;vertice[m]-&gt;minnRoute &lt; secondlen &amp;&amp; graph-&gt;vertice[m]-&gt;minnRoute &gt; minlen) &#123;<br>            <span class="hljs-comment">// If a new path is found, record the path</span><br>            <span class="hljs-keyword">if</span>(secondlen &gt; minlen) &#123;<br>                secondlen = graph-&gt;vertice[m]-&gt;minnRoute;<br>                <span class="hljs-comment">// Reset the path tracking index</span><br>                inde = <span class="hljs-number">1</span>;<br>                <span class="hljs-comment">// Start from the destination node</span><br>                track[<span class="hljs-number">1</span>] = m;<br>                <span class="hljs-comment">// Backtrack from the destination to the source by predecessors to record the path</span><br>                <span class="hljs-type">int</span> position = graph-&gt;vertice[m]-&gt;predecessor;<br>                <span class="hljs-keyword">while</span>(position != <span class="hljs-number">1</span>) &#123;<br>                    track[++inde] = position;<br>                    position = graph-&gt;vertice[position]-&gt;predecessor;<br>                &#125;<br>                <span class="hljs-comment">// Add the source node to the path</span><br>                track[++inde] = position;<br>            &#125;<br>        &#125;<br>    &#125;    <br></code></pre></td></tr></table></figure>
<h4 id="Cycle-Detection">Cycle Detection</h4>
<p>The algorithm also incorporates a depth-first search (DFS) to identify the smallest cycle originating from each node. The cycle’s length is compared to the second-shortest path candidate, and the shorter of the two is chosen as the solution.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">DFS</span><span class="hljs-params">(<span class="hljs-type">int</span> currentNode, <span class="hljs-type">int</span> startNode, <span class="hljs-type">int</span> totalWeight, Graph* <span class="hljs-built_in">map</span>, <span class="hljs-type">int</span>* visited)</span> &#123;<br>    visited[currentNode] = <span class="hljs-number">1</span>; <span class="hljs-comment">// Mark the current node as visited</span><br>    Push(currentNode);        <span class="hljs-comment">// Push the current node onto the stack to keep track of the path</span><br><br>    <span class="hljs-comment">// Iterate through all edges of the current node</span><br>    Edge* edge = <span class="hljs-built_in">map</span>-&gt;vertice[currentNode]-&gt;next;<br>    <span class="hljs-keyword">while</span> (edge != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-comment">// Check if we have returned to the start node, forming a cycle</span><br>        <span class="hljs-keyword">if</span> (edge-&gt;to == startNode &amp;&amp; totalWeight + edge-&gt;weight &lt; minCycle[startNode]) &#123;<br>            <span class="hljs-comment">// If a smaller cycle is found, update the smallest cycle for the start node</span><br>            minCycle[startNode] = totalWeight + edge-&gt;weight;<br>            PrintCycle(startNode, <span class="hljs-built_in">map</span>); <span class="hljs-comment">// Print the path of the cycle</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!visited[edge-&gt;to]) &#123;<br>            <span class="hljs-comment">// Continue DFS if the next node has not been visited</span><br>            DFS(edge-&gt;to, startNode, totalWeight + edge-&gt;weight, <span class="hljs-built_in">map</span>, visited);<br>        &#125;<br>        <span class="hljs-comment">// Move to the next edge</span><br>        edge = edge-&gt;next;<br>    &#125;<br><br>    <span class="hljs-comment">// Backtrack: pop the current node from the stack</span><br>    Pop();<br>    <span class="hljs-comment">// Unmark the current node as visited to allow revisiting in different paths</span><br>    visited[currentNode] = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">FindCycles</span><span class="hljs-params">(Graph* <span class="hljs-built_in">map</span>)</span> &#123;<br>    <span class="hljs-comment">// Initialize the array that will store the length of the smallest cycle for each node</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-built_in">map</span>-&gt;numNodes; i++) &#123;<br>        minCycle[i] = Max_int; <span class="hljs-comment">// Set the initial length to the maximum integer value, effectively infinity</span><br>    &#125;<br><br>    <span class="hljs-comment">// Create and initialize an array to keep track of visited nodes during DFS</span><br>    <span class="hljs-type">int</span> visited[MAX_NODES] = &#123;<span class="hljs-number">0</span>&#125;; <span class="hljs-comment">// 0 indicates that a node has not been visited</span><br><br>    <span class="hljs-comment">// Iterate over all nodes to find cycles starting from each node</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-built_in">map</span>-&gt;numNodes; i++) &#123;<br>        <span class="hljs-comment">// Perform Depth-First Search (DFS) starting from the current node to find cycles</span><br>        DFS(i, i, <span class="hljs-number">0</span>, <span class="hljs-built_in">map</span>, visited); <span class="hljs-comment">// Start DFS with the current node as the start node, total weight as 0</span><br><br>        <span class="hljs-comment">// After DFS, check if a cycle was found for the current node</span><br>        <span class="hljs-keyword">if</span> (minCycle[i] == Max_int) &#123;<br>            <span class="hljs-comment">// If the smallest cycle length is still set to Max_int, no cycle was found</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;No cycle found for vertex %d\n&quot;</span>, i);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// If a cycle was found, print the length of the smallest cycle for the current node</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Minimum cycle length for vertex %d is %d\n&quot;</span>, i, minCycle[i]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="Data-Structures">Data Structures</h4>
<p>The implementation uses adjacency lists to represent the graph, with vertices and edges encapsulated in structs. A priority queue, realized through a min-heap, is employed for efficient retrieval of the node with the smallest tentative distance during the Dijkstra algorithm’s execution. Additionally, arrays are used to track the shortest path, the existence of cycles, and other intermediate states within the algorithm.</p>
<p>Data structures defined are as follow</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> m, n; <span class="hljs-comment">// Number of nodes (m) and edges (n)</span><br><span class="hljs-type">int</span> from, to, weight; <span class="hljs-comment">// Variables to read edge data (from node, to node, weight of edge)</span><br><span class="hljs-type">int</span> minlen = Max_int; <span class="hljs-comment">// Length of the shortest path found in the first round of Dijkstra&#x27;s algorithm</span><br><span class="hljs-type">int</span> secondlen = Max_int; <span class="hljs-comment">// Length of the second shortest path</span><br><span class="hljs-type">int</span> minCycle[MAX_NODES]; <span class="hljs-comment">// Stores the length of the shortest cycle for each node</span><br><br><span class="hljs-type">int</span> <span class="hljs-built_in">stack</span>[MAX_NODES]; <span class="hljs-comment">// Array to simulate a stack for storing paths</span><br><span class="hljs-type">int</span> top = <span class="hljs-number">-1</span>; <span class="hljs-comment">// Stack pointer indicating the top of the stack</span><br><span class="hljs-type">int</span> loops[MAX_NODES][MAX_NODES]; <span class="hljs-comment">// Stores cycles in the original graph</span><br><span class="hljs-type">int</span> MinTrack[MAX_NODES]; <span class="hljs-comment">// Stores the shortest path from node 1 to each node (in the original graph)</span><br><br><span class="hljs-type">int</span> track[<span class="hljs-number">1001</span>]; <span class="hljs-comment">// Stores the nodes visited in the shortest path</span><br><span class="hljs-type">int</span> inde = <span class="hljs-number">1</span>; <span class="hljs-comment">// Index for tracking the elements in the array track[]</span><br><br><span class="hljs-type">int</span> Fixedtrack[MAX_NODES]; <span class="hljs-comment">// Stores the shortest path of the original graph</span><br><span class="hljs-type">int</span> Fixedlen; <span class="hljs-comment">// Length of the path stored in Fixedtrack[]</span><br><br><span class="hljs-comment">// Definition of an Edge in the graph</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span> &#123;</span><br>    <span class="hljs-type">int</span> to; <span class="hljs-comment">// Destination node of the edge</span><br>    <span class="hljs-type">int</span> weight; <span class="hljs-comment">// Weight of the edge</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span> *<span class="hljs-title">next</span>;</span> <span class="hljs-comment">// Pointer to the next edge in the list</span><br>&#125; Edge;<br><br><span class="hljs-comment">// Definition of a Vertex in the graph</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vertex</span>&#123;</span><br>    <span class="hljs-type">int</span> predecessor; <span class="hljs-comment">// Predecessor node in the shortest path</span><br>    <span class="hljs-type">int</span> number; <span class="hljs-comment">// Number of the current node</span><br>    <span class="hljs-type">int</span> minnRoute; <span class="hljs-comment">// Length of the shortest path from node 1 to the current node</span><br>    <span class="hljs-type">int</span> loop[<span class="hljs-number">1001</span>]; <span class="hljs-comment">// Array to store a cycle if found starting from this node</span><br>    Edge *next; <span class="hljs-comment">// Pointer to the list of edges connected to this node</span><br>&#125;Vertex;<br><br><span class="hljs-comment">// Definition of a Graph</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Graph</span> &#123;</span><br>    <span class="hljs-type">int</span> numNodes; <span class="hljs-comment">// Number of nodes in the graph</span><br>    Vertex *vertice[MAX_NODES]; <span class="hljs-comment">// Array of pointers to vertices, representing the adjacency list</span><br>&#125; Graph;<br><br><span class="hljs-type">int</span> MinHeap[MAX_NODES]; <span class="hljs-comment">// Min-heap to store node numbers for Dijkstra&#x27;s algorithm</span><br><span class="hljs-type">int</span> isvisited[MAX_NODES]; <span class="hljs-comment">// Array to track visited nodes during the search</span><br>Graph* graph; <span class="hljs-comment">// Pointer to the graph</span><br></code></pre></td></tr></table></figure>
<h4 id="Complexity-Analysis">Complexity Analysis</h4>
<p>The time complexity of Dijkstra’s algorithm is <strong>O((M+N)logM)</strong>, where M is the number of nodes and N is the number of edges. The edge blocking and re-evaluation process add an additional factor, as the Dijkstra algorithm is applied iteratively. Cycle detection through DFS contributes <strong>O(N+M)</strong> per node for a complete traversal. The overall complexity is dominated by the repeated application of Dijkstra’s algorithm.</p>
<h4 id="Conclusion">Conclusion</h4>
<p>The specified algorithm is designed to balance computational efficiency with the need to address the non-trivial problem of second-shortest path discovery in graphs that may contain numerous cycles and varying edge lengths. The following chapters will delve into the implementation details, providing code snippets and explanations of key functions within the algorithm.</p>
<h3 id="Chapter-3-Testing-results">Chapter 3 Testing results</h3>
<p></p>
<h3 id="Chapter-4-Analysis-and-Comments">Chapter 4 Analysis and Comments</h3>
<p>In the analysis above, weve reached the conclusion that the time complexity of Dijkstra algorithm is <strong>O((M+N)logM)</strong> and FindCycle has the time complexity of  <strong>O(N+M)</strong>, it’s highly acceptable because of the application of priority queue(min heap in the code) to optimize the Dijkstra process.</p>
<p></p>
<h4 id="Potential-Improvement">Potential Improvement</h4>
<p></p>
<h3 id="Appendix-Source-Code">Appendix : Source Code</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_NODES 1005</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> Max_int 2147483647</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> Head 1</span><br><br><span class="hljs-type">int</span> m, n; <span class="hljs-comment">// Number of nodes (m) and edges (n)</span><br><span class="hljs-type">int</span> from, to, weight; <span class="hljs-comment">// Variables to read edge data (from node, to node, weight of edge)</span><br><span class="hljs-type">int</span> minlen = Max_int; <span class="hljs-comment">// Length of the shortest path found in the first round of Dijkstra&#x27;s algorithm</span><br><span class="hljs-type">int</span> secondlen = Max_int; <span class="hljs-comment">// Length of the second shortest path</span><br><span class="hljs-type">int</span> minCycle[MAX_NODES]; <span class="hljs-comment">// Stores the length of the shortest cycle for each node</span><br><br><span class="hljs-type">int</span> <span class="hljs-built_in">stack</span>[MAX_NODES]; <span class="hljs-comment">// Array to simulate a stack for storing paths</span><br><span class="hljs-type">int</span> top = <span class="hljs-number">-1</span>; <span class="hljs-comment">// Stack pointer indicating the top of the stack</span><br><span class="hljs-type">int</span> loops[MAX_NODES][MAX_NODES]; <span class="hljs-comment">// Stores cycles in the original graph</span><br><span class="hljs-type">int</span> MinTrack[MAX_NODES]; <span class="hljs-comment">// Stores the shortest path from node 1 to each node (in the original graph)</span><br><br><span class="hljs-type">int</span> track[<span class="hljs-number">1001</span>]; <span class="hljs-comment">// Stores the nodes visited in the shortest path</span><br><span class="hljs-type">int</span> inde = <span class="hljs-number">1</span>; <span class="hljs-comment">// Index for tracking the elements in the array track[]</span><br><br><span class="hljs-type">int</span> Fixedtrack[MAX_NODES]; <span class="hljs-comment">// Stores the shortest path of the original graph</span><br><span class="hljs-type">int</span> Fixedlen; <span class="hljs-comment">// Length of the path stored in Fixedtrack[]</span><br><br><span class="hljs-comment">// Definition of an Edge in the graph</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span> &#123;</span><br>    <span class="hljs-type">int</span> to; <span class="hljs-comment">// Destination node of the edge</span><br>    <span class="hljs-type">int</span> weight; <span class="hljs-comment">// Weight of the edge</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span> *<span class="hljs-title">next</span>;</span> <span class="hljs-comment">// Pointer to the next edge in the list</span><br>&#125; Edge;<br><br><span class="hljs-comment">// Definition of a Vertex in the graph</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vertex</span>&#123;</span><br>    <span class="hljs-type">int</span> predecessor; <span class="hljs-comment">// Predecessor node in the shortest path</span><br>    <span class="hljs-type">int</span> number; <span class="hljs-comment">// Number of the current node</span><br>    <span class="hljs-type">int</span> minnRoute; <span class="hljs-comment">// Length of the shortest path from node 1 to the current node</span><br>    <span class="hljs-type">int</span> loop[<span class="hljs-number">1001</span>]; <span class="hljs-comment">// Array to store a cycle if found starting from this node</span><br>    Edge *next; <span class="hljs-comment">// Pointer to the list of edges connected to this node</span><br>&#125;Vertex;<br><br><span class="hljs-comment">// Definition of a Graph</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Graph</span> &#123;</span><br>    <span class="hljs-type">int</span> numNodes; <span class="hljs-comment">// Number of nodes in the graph</span><br>    Vertex *vertice[MAX_NODES]; <span class="hljs-comment">// Array of pointers to vertices, representing the adjacency list</span><br>&#125; Graph;<br><br><span class="hljs-type">int</span> MinHeap[MAX_NODES]; <span class="hljs-comment">// Min-heap to store node numbers for Dijkstra&#x27;s algorithm</span><br><span class="hljs-type">int</span> isvisited[MAX_NODES]; <span class="hljs-comment">// Array to track visited nodes during the search</span><br>Graph* graph; <span class="hljs-comment">// Pointer to the graph</span><br><br><span class="hljs-comment">// The percolateUp function is used to restore the heap property by moving a node up in the heap.</span><br><span class="hljs-comment">// This is necessary when the value of a node becomes smaller than its parent&#x27;s value, </span><br><span class="hljs-comment">// which can happen after a decrease-key operation in a min-heap.</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">percolateUp</span><span class="hljs-params">(<span class="hljs-type">int</span> position)</span> &#123;<br>    <span class="hljs-comment">// Keep adjusting the heap upwards from the given position.</span><br>    <span class="hljs-keyword">while</span> (position &gt; <span class="hljs-number">1</span> &amp;&amp; graph-&gt;vertice[MinHeap[position]]-&gt;minnRoute &lt; graph-&gt;vertice[MinHeap[position/<span class="hljs-number">2</span>]]-&gt;minnRoute) &#123;<br>        <span class="hljs-comment">// If the node&#x27;s minnRoute (shortest path distance) is less than its parent&#x27;s,</span><br>        <span class="hljs-comment">// they are swapped to maintain the min-heap property.</span><br>        <span class="hljs-type">int</span> temp = MinHeap[position];<br>        MinHeap[position] = MinHeap[position / <span class="hljs-number">2</span>];<br>        MinHeap[position / <span class="hljs-number">2</span>] = temp;<br><br>        <span class="hljs-comment">// Move up to the parent&#x27;s position to continue the percolation as necessary.</span><br>        position /= <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// The percolateDown function is used to restore the heap property by moving a node down in the heap.</span><br><span class="hljs-comment">// This is necessary when the value of a node is greater than one of its children&#x27;s values, </span><br><span class="hljs-comment">// which can happen after an extract-min or delete operation in a min-heap.</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">percolateDown</span><span class="hljs-params">(<span class="hljs-type">int</span> position, <span class="hljs-type">int</span> hSize)</span> &#123;<br>    <span class="hljs-comment">// Begin percolation down from the given position.</span><br>    <span class="hljs-keyword">while</span> (position * <span class="hljs-number">2</span> &lt;= hSize) &#123;  <span class="hljs-comment">// Check if the current node has at least one child.</span><br>        <span class="hljs-type">int</span> child = position * <span class="hljs-number">2</span>;  <span class="hljs-comment">// Position of the left child.</span><br>        <span class="hljs-comment">// Determine the smaller of the two children (if there are two) to maintain the min-heap property.</span><br>        <span class="hljs-keyword">if</span> (child &lt; hSize &amp;&amp; graph-&gt;vertice[MinHeap[child]]-&gt;minnRoute &gt; graph-&gt;vertice[MinHeap[child + <span class="hljs-number">1</span>]]-&gt;minnRoute) &#123;<br>            child++;  <span class="hljs-comment">// If the right child is smaller, choose the right child&#x27;s position.</span><br>        &#125;<br>        <span class="hljs-comment">// If the parent&#x27;s minnRoute is less than or equal to the smaller child&#x27;s, the heap is correct and we stop.</span><br>        <span class="hljs-keyword">if</span> (graph-&gt;vertice[MinHeap[position]]-&gt;minnRoute &lt;= graph-&gt;vertice[MinHeap[child]]-&gt;minnRoute) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-comment">// Swap the parent with the smaller child.</span><br>        <span class="hljs-type">int</span> temp = MinHeap[position];<br>        MinHeap[position] = MinHeap[child];<br>        MinHeap[child] = temp;<br><br>        <span class="hljs-comment">// Move down to the child&#x27;s position to continue the percolation as necessary.</span><br>        position = child;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Initialize</span><span class="hljs-params">(Graph* <span class="hljs-built_in">map</span>)</span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= m;i++)&#123;<br>        Vertex* newVertice;<br>        newVertice = (Vertex*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> vertex));<br>        <span class="hljs-built_in">map</span>-&gt;vertice[i] = newVertice;<br>        <span class="hljs-built_in">map</span>-&gt;vertice[i]-&gt;minnRoute = Max_int; <span class="hljs-comment">// initialize it as the max int</span><br>        newVertice-&gt;number = i;<br>        newVertice-&gt;next = <span class="hljs-literal">NULL</span>;<br>        newVertice-&gt;predecessor = <span class="hljs-number">-1</span>; <span class="hljs-comment">// no predecessor for every vertex before reading edges</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt;= <span class="hljs-number">1000</span>;i++) newVertice-&gt;loop[i] = <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-built_in">map</span>-&gt;vertice[<span class="hljs-number">1</span>]-&gt;minnRoute = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">map</span>-&gt;vertice[<span class="hljs-number">1</span>]-&gt;predecessor = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">BuildMap</span><span class="hljs-params">(Graph* <span class="hljs-built_in">map</span>, <span class="hljs-type">int</span> begin, <span class="hljs-type">int</span> end, <span class="hljs-type">int</span> len)</span>&#123;<br>    Edge* newEdge;<br>    newEdge = (Edge*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Edge));<br>    newEdge-&gt;to = end;<br>    newEdge-&gt;weight = len;<br>    newEdge-&gt;next = <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-comment">// store the new edge into the graph</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">map</span>-&gt;vertice[begin]-&gt;next == <span class="hljs-literal">NULL</span>) <span class="hljs-built_in">map</span>-&gt;vertice[begin]-&gt;next = newEdge;<br>    <span class="hljs-keyword">else</span> &#123;<br>        Edge* track = <span class="hljs-built_in">map</span>-&gt;vertice[begin]-&gt;next;<br>        <span class="hljs-keyword">while</span>(track-&gt;next != <span class="hljs-literal">NULL</span>) track = track-&gt;next;<br>        track-&gt;next = newEdge;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">Max</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>&#123;<br>    <span class="hljs-keyword">return</span> a &gt; b ? a : b;<br>&#125;<br><br><span class="hljs-comment">// Implementation of Dijkstra&#x27;s algorithm to find the shortest path in a graph</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">Dijkstra</span><span class="hljs-params">(Graph* <span class="hljs-built_in">map</span>)</span> &#123;<br>    <span class="hljs-comment">// Start with node 1 in the min heap (priority queue)</span><br>    MinHeap[Head] = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> HeapSize = <span class="hljs-number">1</span>; <span class="hljs-comment">// Initialize heap size</span><br><br>    <span class="hljs-comment">// Loop to process all nodes in the graph</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>        <span class="hljs-comment">// Extract node with the smallest distance</span><br>        <span class="hljs-type">int</span> currentNode = MinHeap[Head];<br><br>        <span class="hljs-comment">// Access all edges connected to the current node</span><br>        Edge* currentEdge = <span class="hljs-built_in">map</span>-&gt;vertice[currentNode]-&gt;next;<br><br>        <span class="hljs-comment">// Mark the current node as visited</span><br>        isvisited[currentNode] = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">// Remove the top element from the heap</span><br>        <span class="hljs-keyword">if</span>(HeapSize == <span class="hljs-number">1</span>) &#123;<br>            HeapSize--;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            MinHeap[Head] = MinHeap[HeapSize--];<br>            percolateDown(Head, HeapSize); <span class="hljs-comment">// Restore heap property</span><br>        &#125;<br><br>        <span class="hljs-comment">// Traverse all edges of the current node</span><br>        <span class="hljs-keyword">while</span> (currentEdge != <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-type">int</span> nextNode = currentEdge-&gt;to; <span class="hljs-comment">// Get the adjacent node</span><br><br>            <span class="hljs-comment">// Check if a shorter path is found</span><br>            <span class="hljs-keyword">if</span> (currentEdge-&gt;weight + <span class="hljs-built_in">map</span>-&gt;vertice[currentNode]-&gt;minnRoute &lt; <span class="hljs-built_in">map</span>-&gt;vertice[nextNode]-&gt;minnRoute) &#123;<br>                <span class="hljs-comment">// Update the distance and predecessor</span><br>                <span class="hljs-built_in">map</span>-&gt;vertice[nextNode]-&gt;minnRoute = currentEdge-&gt;weight + <span class="hljs-built_in">map</span>-&gt;vertice[currentNode]-&gt;minnRoute;<br>                <span class="hljs-built_in">map</span>-&gt;vertice[nextNode]-&gt;predecessor = currentNode;<br><br>                <span class="hljs-comment">// Add the node to the heap if it hasn&#x27;t been visited</span><br>                <span class="hljs-keyword">if</span> (!isvisited[nextNode]) &#123;<br>                    MinHeap[++HeapSize] = nextNode;<br>                    percolateUp(HeapSize); <span class="hljs-comment">// Maintain heap property</span><br>                    isvisited[nextNode] = <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-comment">// Move to the next edge in the adjacency list</span><br>            currentEdge = currentEdge-&gt;next;<br>        &#125;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Push</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span> &#123;<br>    <span class="hljs-built_in">stack</span>[++top] = v; <br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Pop</span><span class="hljs-params">()</span> &#123;<br>    top--; <br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">PrintCycle</span><span class="hljs-params">(<span class="hljs-type">int</span> currentNode, Graph* <span class="hljs-built_in">map</span>)</span> &#123;<br>    <span class="hljs-comment">// 当找到一个环时，打印出环的路径</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= top; i++) &#123;<br>        <span class="hljs-built_in">map</span>-&gt;vertice[currentNode]-&gt;loop[i] = <span class="hljs-built_in">stack</span>[i];<br>    &#125;<br>    <span class="hljs-built_in">map</span>-&gt;vertice[currentNode]-&gt;loop[top+<span class="hljs-number">1</span>] = <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">DFS</span><span class="hljs-params">(<span class="hljs-type">int</span> currentNode, <span class="hljs-type">int</span> startNode, <span class="hljs-type">int</span> totalWeight, Graph* <span class="hljs-built_in">map</span>, <span class="hljs-type">int</span>* visited)</span> &#123;<br>    visited[currentNode] = <span class="hljs-number">1</span>; <span class="hljs-comment">// Mark the current node as visited</span><br>    Push(currentNode);        <span class="hljs-comment">// Push the current node onto the stack to keep track of the path</span><br><br>    <span class="hljs-comment">// Iterate through all edges of the current node</span><br>    Edge* edge = <span class="hljs-built_in">map</span>-&gt;vertice[currentNode]-&gt;next;<br>    <span class="hljs-keyword">while</span> (edge != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-comment">// Check if we have returned to the start node, forming a cycle</span><br>        <span class="hljs-keyword">if</span> (edge-&gt;to == startNode &amp;&amp; totalWeight + edge-&gt;weight &lt; minCycle[startNode]) &#123;<br>            <span class="hljs-comment">// If a smaller cycle is found, update the smallest cycle for the start node</span><br>            minCycle[startNode] = totalWeight + edge-&gt;weight;<br>            PrintCycle(startNode, <span class="hljs-built_in">map</span>); <span class="hljs-comment">// Print the path of the cycle</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!visited[edge-&gt;to]) &#123;<br>            <span class="hljs-comment">// Continue DFS if the next node has not been visited</span><br>            DFS(edge-&gt;to, startNode, totalWeight + edge-&gt;weight, <span class="hljs-built_in">map</span>, visited);<br>        &#125;<br>        <span class="hljs-comment">// Move to the next edge</span><br>        edge = edge-&gt;next;<br>    &#125;<br><br>    <span class="hljs-comment">// Backtrack: pop the current node from the stack</span><br>    Pop();<br>    <span class="hljs-comment">// Unmark the current node as visited to allow revisiting in different paths</span><br>    visited[currentNode] = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">FindCycles</span><span class="hljs-params">(Graph* <span class="hljs-built_in">map</span>)</span> &#123;<br>    <span class="hljs-comment">// Initialize the array that will store the length of the smallest cycle for each node</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-built_in">map</span>-&gt;numNodes; i++) &#123;<br>        minCycle[i] = Max_int; <span class="hljs-comment">// Set the initial length to the maximum integer value, effectively infinity</span><br>    &#125;<br><br>    <span class="hljs-comment">// Create and initialize an array to keep track of visited nodes during DFS</span><br>    <span class="hljs-type">int</span> visited[MAX_NODES] = &#123;<span class="hljs-number">0</span>&#125;; <span class="hljs-comment">// 0 indicates that a node has not been visited</span><br><br>    <span class="hljs-comment">// Iterate over all nodes to find cycles starting from each node</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-built_in">map</span>-&gt;numNodes; i++) &#123;<br>        <span class="hljs-comment">// Perform Depth-First Search (DFS) starting from the current node to find cycles</span><br>        DFS(i, i, <span class="hljs-number">0</span>, <span class="hljs-built_in">map</span>, visited); <span class="hljs-comment">// Start DFS with the current node as the start node, total weight as 0</span><br>    &#125;<br>&#125;<br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    graph = (Graph*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Graph)); <span class="hljs-comment">// Allocate memory for a graph structure and assign it to the graph pointer</span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,&amp;m, &amp;n); <span class="hljs-comment">// Input the number of nodes (m) and edges (n)</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) isvisited[i] = <span class="hljs-number">0</span>; <span class="hljs-comment">// Initialize the visited array with zeros indicating that no nodes have been visited yet</span><br>    graph-&gt;numNodes = m; <span class="hljs-comment">// Set the number of nodes in the graph</span><br>    Initialize(graph); <span class="hljs-comment">// Initialize the graph with nodes</span><br><br>    <span class="hljs-comment">// Read the edge data and store it in the graph</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>, &amp;from, &amp;to, &amp;weight); <span class="hljs-comment">// Input the edge data: start node, end node, and weight</span><br>        BuildMap(graph, from, to, weight); <span class="hljs-comment">// Add the edge to the graph</span><br>    &#125;<br><br>    <span class="hljs-comment">// Apply Dijkstra&#x27;s algorithm to find the shortest path in the initial graph</span><br>    Dijkstra(graph);<br>    minlen = graph-&gt;vertice[m]-&gt;minnRoute; <span class="hljs-comment">// Store the shortest path length in minlen</span><br><br>    <span class="hljs-comment">/* Debugging code: Check the shortest path length and predecessor of each node</span><br><span class="hljs-comment">    for(int i = 1; i &lt;= m; i++) &#123;</span><br><span class="hljs-comment">        MinTrack[i] = graph-&gt;vertice[i]-&gt;minnRoute;</span><br><span class="hljs-comment">        printf(&quot;%d %d\n&quot;, graph-&gt;vertice[i]-&gt;minnRoute, graph-&gt;vertice[i]-&gt;predecessor);</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">    */</span><br><br>    <span class="hljs-comment">// Find the nodes along the shortest path</span><br>    track[<span class="hljs-number">1</span>] = m; <span class="hljs-comment">// Start from the destination node</span><br>    <span class="hljs-type">int</span> position = graph-&gt;vertice[m]-&gt;predecessor; <span class="hljs-comment">// Initialize position with the predecessor of the destination node</span><br><br>    <span class="hljs-comment">// Backtrack from the destination node to the start node, storing the path in reverse order</span><br>    <span class="hljs-keyword">while</span>(position != <span class="hljs-number">1</span>) &#123;<br>        track[++inde] = position; <span class="hljs-comment">// Store the node in the path</span><br>        position = graph-&gt;vertice[position]-&gt;predecessor; <span class="hljs-comment">// Move to the predecessor node</span><br>    &#125;<br>    track[++inde] = <span class="hljs-number">1</span>; <span class="hljs-comment">// Store the start node in the path</span><br>    <span class="hljs-comment">// The path in track[] is now stored in reverse order, e.g., for a path 1 2 3 6, track[] contains 6 3 2 1</span><br><br>    Fixedlen = inde; <span class="hljs-comment">// Store the length of the path</span><br>    <span class="hljs-comment">// Store the shortest path in Fixedtrack[] in reverse order</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = inde; i &gt;= <span class="hljs-number">1</span>; i--) Fixedtrack[i] = track[i];<br><br>    <span class="hljs-comment">// Find cycles in the initial graph</span><br>    FindCycles(graph);<br><br>    <span class="hljs-comment">// Store the cycle information in the loops 2D array</span><br><br>    <span class="hljs-comment">/*for(int i = 1; i &lt;= m; i++) &#123;</span><br><span class="hljs-comment">        for(int j = 0; graph-&gt;vertice[i]-&gt;loop[j] != -1; j++) &#123;</span><br><span class="hljs-comment">            printf(&quot;%d &quot;, graph-&gt;vertice[i]-&gt;loop[j]); // Print the cycle</span><br><span class="hljs-comment">            loops[i][j] = graph-&gt;vertice[i]-&gt;loop[j]; // Store the cycle in loops array</span><br><span class="hljs-comment">            loops[i][j+1] = -1; // Mark the end of the cycle</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">        printf(&quot;\n&quot;); // Print a new line after each cycle</span><br><span class="hljs-comment">    &#125;*/</span><br><br><br>    <span class="hljs-comment">/*puts(&quot;check:&quot;);</span><br><span class="hljs-comment">    for(int i = 1;i &lt;= m;i++)&#123;</span><br><span class="hljs-comment">        for(int j = 0;graph-&gt;vertice[i]-&gt;loop[j] != -1;j++)&#123;</span><br><span class="hljs-comment">            printf(&quot;%d &quot;,graph-&gt;vertice[i]-&gt;loop[j]);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">        printf(&quot;\n&quot;);</span><br><span class="hljs-comment">    &#125;*/</span><br><br>    <span class="hljs-type">int</span> flag = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">// Block each path in the shortest path and run Dijkstra&#x27;s algorithm again to find the next shortest path</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= inde - <span class="hljs-number">1</span>; i++) &#123; <span class="hljs-comment">// For a path with n nodes, there are n-1 edges</span><br>        <span class="hljs-comment">// Reset the visited status for all nodes</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) isvisited[j] = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// Get the edge in the stored shortest path. If track[] stored 6 3 2 1, and i=1, then currentEdge is the first edge from node 3</span><br>        Edge* currentEdge = graph-&gt;vertice[track[i+<span class="hljs-number">1</span>]]-&gt;next;<br>        <span class="hljs-comment">// Find the edge pointing to track[i]</span><br>        <span class="hljs-keyword">while</span>(currentEdge-&gt;to != track[i]) currentEdge = currentEdge-&gt;next;<br><br>        <span class="hljs-comment">// Store the original length of the edge</span><br>        <span class="hljs-type">int</span> temp = currentEdge-&gt;weight;<br>        <span class="hljs-comment">// Assign a very high value to the current edge, effectively blocking it from being used</span><br>        currentEdge-&gt;weight = Max_int - <span class="hljs-number">5000000</span>;<br><br>        <span class="hljs-comment">// Initialize the graph to run Dijkstra&#x27;s algorithm</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= m; k++) &#123;<br>            graph-&gt;vertice[k]-&gt;minnRoute = Max_int;<br>            graph-&gt;vertice[k]-&gt;predecessor = <span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-comment">// Set the starting node&#x27;s distance to 0 and predecessor to itself</span><br>        graph-&gt;vertice[<span class="hljs-number">1</span>]-&gt;minnRoute = <span class="hljs-number">0</span>;<br>        graph-&gt;vertice[<span class="hljs-number">1</span>]-&gt;predecessor = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">// Run Dijkstra&#x27;s algorithm with the current edge blocked</span><br>        Dijkstra(graph);<br><br>        <span class="hljs-comment">// Print the updated distances and predecessors after running Dijkstra</span><br>        <span class="hljs-comment">/*for(int j = 1; j &lt;= m; j++) printf(&quot;%d %d\n&quot;, graph-&gt;vertice[j]-&gt;minnRoute, graph-&gt;vertice[j]-&gt;predecessor);</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-comment">// Restore the original length of the current edge</span><br>        currentEdge-&gt;weight = temp;<br><br>        <span class="hljs-comment">// Update the length of the second shortest path</span><br>        <span class="hljs-comment">// Check if the new path is shorter than the second shortest but longer than the shortest path</span><br>        <span class="hljs-keyword">if</span>(graph-&gt;vertice[m]-&gt;minnRoute &lt; secondlen &amp;&amp; graph-&gt;vertice[m]-&gt;minnRoute &gt; minlen) &#123;<br>            <span class="hljs-comment">// If a new path is found, record the path</span><br>            <span class="hljs-keyword">if</span>(secondlen &gt; minlen) &#123;<br>                secondlen = graph-&gt;vertice[m]-&gt;minnRoute;<br>                <span class="hljs-comment">// Reset the path tracking index</span><br>                inde = <span class="hljs-number">1</span>;<br>                <span class="hljs-comment">// Start from the destination node</span><br>                track[<span class="hljs-number">1</span>] = m;<br>                <span class="hljs-comment">// Backtrack from the destination to the source by predecessors to record the path</span><br>                <span class="hljs-type">int</span> position = graph-&gt;vertice[m]-&gt;predecessor;<br>                <span class="hljs-keyword">while</span>(position != <span class="hljs-number">1</span>) &#123;<br>                    track[++inde] = position;<br>                    position = graph-&gt;vertice[position]-&gt;predecessor;<br>                &#125;<br>                <span class="hljs-comment">// Add the source node to the path</span><br>                track[++inde] = position;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// If no second shortest path has been found through the previous process,</span><br>    <span class="hljs-comment">// attempt to find it by traversing the smallest cycle.</span><br>    <span class="hljs-type">int</span> minloop = Max_int;<br>    <span class="hljs-type">int</span> minloopindex;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= Fixedlen; i++)&#123;<br>        <span class="hljs-comment">// Check if the current node is part of a smaller cycle than previously found.</span><br>        <span class="hljs-keyword">if</span>(minCycle[Fixedtrack[i]] &lt; minloop)&#123;<br>            minloop = minCycle[Fixedtrack[i]];<br>            minloopindex = Fixedtrack[i];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// Set a flag to indicate whether the second shortest path has been found.</span><br>    <span class="hljs-comment">// If the sum of the shortest path and the minimum cycle is less than the second shortest path,</span><br>    <span class="hljs-comment">// then we have not yet found a valid second shortest path.</span><br>    <span class="hljs-type">int</span> flag = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(minlen + minloop &lt; secondlen) flag = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// If the flag is still set (indicating a second shortest path has been found),</span><br>    <span class="hljs-comment">// print the length of the second shortest path and the path itself.</span><br>    <span class="hljs-keyword">if</span>(flag)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, secondlen);<br>        <span class="hljs-comment">// Print the path in reverse order as it was stored.</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = inde; i &gt;= <span class="hljs-number">1</span>; i--) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %d&quot;</span>, track[i]);<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// If a second shortest path hasn&#x27;t been found, print the sum of the shortest path</span><br>        <span class="hljs-comment">// and the minimum cycle as the second shortest path.</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, minlen + minloop);<br>        <span class="hljs-comment">// Print the path, including the smallest cycle found along the path.</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = Fixedlen; i &gt;= <span class="hljs-number">1</span>; i--)&#123;<br>            <span class="hljs-comment">// If the current node is not the starting node of the minimum cycle,</span><br>            <span class="hljs-comment">// print it as part of the path.</span><br>            <span class="hljs-keyword">if</span>(Fixedtrack[i] != minloopindex) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %d&quot;</span>, Fixedtrack[i]);<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// If the current node is the starting node of the minimum cycle,</span><br>                <span class="hljs-comment">// print the entire cycle, then continue printing the rest of the path.</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; graph-&gt;vertice[minloopindex]-&gt;loop[j] != <span class="hljs-number">-1</span>; j++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %d&quot;</span>, graph-&gt;vertice[minloopindex]-&gt;loop[j]);<br>                <span class="hljs-comment">// After printing the cycle, print the node where the cycle begins to indicate closure of the cycle.</span><br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %d&quot;</span>, minloopindex);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="Declaration">Declaration</h3>
<p><strong>I hereby declare that all the work done in this project titled &quot;MAXIMUM SUBMATRIX SUM PROBLEM &quot; is of my independent effort.</strong></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/" class="category-chain-item">课程笔记</a>
  
  
    <span>></span>
    
  <a href="/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/2023-2024%E7%A7%8B%E5%86%AC%E5%AD%A6%E6%9C%9F/" class="category-chain-item">2023-2024秋冬学期</a>
  
  
    <span>></span>
    
  <a href="/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/2023-2024%E7%A7%8B%E5%86%AC%E5%AD%A6%E6%9C%9F/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/" class="category-chain-item">数据结构基础</a>
  
  

  

  

      </span>
    
  
</span>

    </div>
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>FDSProject3Report</div>
      <div>http://example.com/2023/11/08/FDSProject3Report/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Ice Bear</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年11月8日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/11/10/Union-Find/" title="Union/Find">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Union/Find</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/11/06/Dijkstra/" title="Dijkstra">
                        <span class="hidden-mobile">Dijkstra</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
